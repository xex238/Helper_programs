import cv2 # Подключение opencv
import os # Множество функций для работы с ОС
import glob # Позволяет работать с масками файлов или шаблонами

# variant 2
path_1 = "C:/Users/dima0/OneDrive/Рабочий стол/Учебники/6 семестр/Практика/trainset"
path_2 = "C:/Users/dima0/OneDrive/Рабочий стол/Учебники/6 семестр/Практика/validationset"
fileList_1 = glob.glob(os.path.join(path_1, "*.avi"))
fileList_2 = glob.glob(os.path.join(path_2, "*.avi"))
for filename_1 in fileList_1:
  print(filename_1)
for filename_2 in fileList_2:
  print(filename_2)
    
# Попытка открыть одно видео
one_video = fileList_1[2] # Берём путь к первому видео из списка
print(one_video) # Выводим путь на экран

cap = cv2.VideoCapture(one_video) # Создаём экземпляр класса "видео"
frame_list = [] # Создаём список с кадрами
while (cap.isOpened()):
    ret, frame = cap.read()
    #print (ret)
    if (cv2.waitKey(1) & 0xFF == ord('q') or ret == False):
        break
    #gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # Чёрно-белый кадр
    #color_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) # Цветной кадр (перестановка цветов в кадре)
    color_frame = frame
    frame_list.append(color_frame) # Запись кадра в массив
    #cv2.imshow('frame', color_frame) # Воспроизвести кадр

print(len(frame_list)) # Вывод длины списка кадров

# Вырезание каждого шестого кадра из списка
new_frame_list = []
i = 0
j = 0
for frame in frame_list:
    print(i)
    if (i % 6 == 0):
        new_frame_list.append(frame_list[i])
        j = j + 1
    i = i + 1

print(len(new_frame_list)) # Вывод в консоль длины нового списка кадров

first_frame = new_frame_list[1]
first_frame = cv2.resize(first_frame, (700, 350))
cv2.imshow('First frame', first_frame)

# Ожидание нажатия клавиши "q" перед закрытием всех окон
while(1):
    if (cv2.waitKey(1) == ord("q")):
        break


# Код программы для подбора цветогаммы (я не знаю, как это назвать по-другому :D)
def nothing(x):
    pass

cap = first_frame # Один первый кадр
cv2.namedWindow('result')

cv2.createTrackbar('min_b', 'result', 0, 255, nothing)
cv2.createTrackbar('min_g', 'result', 0, 255, nothing)
cv2.createTrackbar('min_r', 'result', 0, 255, nothing)

cv2.createTrackbar('max_b', 'result', 0, 255, nothing)
cv2.createTrackbar('max_g', 'result', 0, 255, nothing)
cv2.createTrackbar('max_r', 'result', 0, 255, nothing)

while(True):
    frame = cap
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    cv2.imshow("hsv", hsv)

    min_b = cv2.getTrackbarPos('min_b', 'result')
    min_g = cv2.getTrackbarPos('min_g', 'result')
    min_r = cv2.getTrackbarPos('min_r', 'result')

    max_b = cv2.getTrackbarPos('max_b', 'result')
    max_g = cv2.getTrackbarPos('max_g', 'result')
    max_r = cv2.getTrackbarPos('max_r', 'result')

    # Размытие матрицы hsv
    #hsv = cv2.blur(hsv, (5, 5))
    #cv2.imshow("Blur", hsv)

    mask = cv2.inRange(hsv, (min_b, min_g, min_r), (max_b, max_g, max_r))
    cv2.imshow('mask', mask)

    # Уменьшение ряби (по умолчанию None - это матрица 3х3) (было 2 и 4 итерации соответственно)
    mask_Er = cv2.erode(mask, None, iterations = 2)
    cv2.imshow("Erode", mask_Er)

    mask_Di = cv2.dilate(mask_Er, None, iterations = 3)
    cv2.imshow("Dilate", mask_Di)

    # Ищем контуры и складируем их в переменную contours (без исключений)
    contours, hierarchy = cv2.findContours(mask_Di.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    frame_2 = frame.copy() # Создаём копию исходного кадра
    # Отображаем контуры поверх изображения
    cv2.drawContours(frame_2, contours, -1, (255, 0, 0), 2, cv2.LINE_AA, hierarchy, 1)
    cv2.imshow("Contours", frame_2)
    print(len(contours)) # Выводится на экран количество найденных контуров
    # Если количество найденных контуров зелёного цвета равно нулю, то переходим к следующему кадру.
    # В противном случае смотрим на количество контуров красного цвета на предыдущем кадре.
    # Если количество контуров красного цвета равно нулю, то переходим к следующему кадру

    #result = cv2.bitwise_and(frame, frame, mask = mask)
    result = cv2.bitwise_and(frame, frame, mask = mask_Di) # Применяем не исходную маску, а модифицированную
    cv2.imshow('result', result)

    # Если нажата клавиша "q", то останавливаем цикл while
    if (cv2.waitKey(1) == ord("q")):
        break
